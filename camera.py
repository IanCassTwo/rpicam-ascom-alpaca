
# -*- coding: utf-8 -*-
#
# -----------------------------------------------------------------------------
# camera.py - Alpaca API responder for Raspberry Pi Camera
#
# Author:   Ian Cass <ian@wheep.co.uk> https://astro.wheep.co.uk
#
# -----------------------------------------------------------------------------
# Edit History:
#   Generated by Python Interface Generator for AlpycaDevice
#
# 10/07/2023   Initial edit

from falcon import Request, Response, HTTPBadRequest, before
from logging import Logger
from shr import ImageArrayResponse, PropertyResponse, MethodResponse, PreProcessRequest, \
                get_request_field, to_bool #, to_int, to_float
from exceptions import *        # Nothing but exception
from picamera2 import Picamera2
from camerastate import CameraState
import libcamera
import numpy as np
import threading

logger: Logger = None
binning = 1
mutex = threading.Lock()

# ----------------------
# MULTI-INSTANCE SUPPORT
# ----------------------
# If this is > 0 then it means that multiple devices of this type are supported.
# Each responder on_get() and on_put() is called with a devnum parameter to indicate
# which instance of the device (0-based) is being called by the client. Leave this
# set to 0 for the simple case of controlling only one instance of this device type.
#
maxdev = 0                      # Single instance

state = CameraState.IDLE
imageReady = False
#exposureDuration = 0
#exposureTime = 0
job = 0
gainvalue = 0

# FIXME Hard coded for HQ camera
SIZE_X = 4056
SIZE_Y = 3040
num_x = SIZE_X
num_y = SIZE_Y
start_x = 0
start_y = 0

# -----------
# DEVICE INFO
# -----------
# Static metadata not subject to configuration changes
class CameraMetadata:
    Name = 'Raspberry Pi Camera'
    Version = 'v0.01'
    Description = 'A Raspberry Pi Camerai using Libcamera'
    DeviceType = 'Camera'
    DeviceID = '0584a99f-0c46-4e27-a312-e2a93dbc65e2'
    Info = 'Alpaca Device\nImplements ICamera\nASCOM Initiative'
    MaxDeviceNumber = maxdev
    InterfaceVersion = 3        # ICameraV3

# Camera Init
picam2 = None
def start_camera_device(logger: logger):
    logger = logger
    global picam2
    picam2 = Picamera2()

# RESOURCE CONTROLLERS

@before(PreProcessRequest(maxdev))
class Action:
    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = MethodResponse(req, NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class CommandBlind:
    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = MethodResponse(req, NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class CommandBool:
    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = MethodResponse(req, NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class CommandString():
    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = MethodResponse(req, NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class Description():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(CameraMetadata.Description, req).json

@before(PreProcessRequest(maxdev))
class DriverInfo():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(CameraMetadata.Info, req).json

@before(PreProcessRequest(maxdev))
class InterfaceVersion():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(CameraMetadata.InterfaceVersion, req).json

@before(PreProcessRequest(maxdev))
class DriverVersion():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(CameraMetadata.Version, req).json

@before(PreProcessRequest(maxdev))
class Name():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(CameraMetadata.Name, req).json

@before(PreProcessRequest(maxdev))
class SupportedActions():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse([], req).json  # Not PropertyNotImplemented

@before(PreProcessRequest(maxdev))
class bayeroffsetx:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # https://ascom-standards.org/Help/Platform/html/P_ASCOM_DeviceInterface_ICameraV3_SensorType.htm
            #
            # FIXME Hard coded for now. HQ camera is BGGR. 
            # Bayer offsets are both zero = RGGB
            # x Bayer offset is 1 and y bayer offset is 0, GRBG.
            # x Bayer offset is 0 and y bayer offset is 1, GBRG.
            # both Bayer offsets are 1, BGGR.
            # FIXME hard coded for now. HQ camera is BGGR
            resp.text = PropertyResponse(1, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Bayeroffsetx failed', ex)).json

@before(PreProcessRequest(maxdev))
class bayeroffsety:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # FIXME Hard coded for now. HQ camera is BGGR
            resp.text = PropertyResponse(1, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Bayeroffsety failed', ex)).json

@before(PreProcessRequest(maxdev))
class binx:

    def on_get(self, req: Request, resp: Response, devnum: int):

        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            resp.text = PropertyResponse(binning, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Binx failed', ex)).json


    def on_put(self, req: Request, resp: Response, devnum: int):
     
        global binning
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        binxstr = get_request_field('BinX', req)      # Raises 400 bad request if missing
        try:
            binx = int(binxstr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'BinX {binxstr} not a valid number.')).json
            return
        ### RANGE CHECK
        if binx < 1 or binx > 2:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'BinX {binxstr} not in range')).json
            return
        try:
            # Set device mode
            mutex.acquire()
            if binx != binning:
                # Binning mode has changed, switch camera resolution
                binning = binx                
                config = picam2.create_still_configuration( {"size": (640, 480)}, queue=False, buffer_count=2, raw={'format': 'SRGGB12','size': (int(SIZE_X / binning), int(SIZE_Y / binning))})
                picam2.stop()
                picam2.configure(config)
                picam2.start()
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Binx failed', ex)).json
        finally:
            mutex.release()

@before(PreProcessRequest(maxdev))
class biny(binx):

    def on_get(self, req: Request, resp: Response, devnum: int):
                super().on_get(req, resp, devnum)

    def on_put(self, req: Request, resp: Response, devnum: int):
     
        global binning
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        binxstr = get_request_field('BinY', req)      # Raises 400 bad request if missing
        try:
            binx = int(binxstr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'BinY {binxstr} not a valid number.')).json
            return
        ### RANGE CHECK
        if binx < 1 or binx > 2:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'BinY {binxstr} not in range')).json
            return
        try:
            # Set device mode
            mutex.acquire()
            if binx != binning:
                # Binning mode has changed, switch camera resolution
                binning = binx                
                config = picam2.create_still_configuration( {"size": (640, 480)}, queue=False, buffer_count=2, raw={'format': 'SRGGB12','size': (int(SIZE_X / binning), int(SIZE_Y / binning))})
                picam2.stop()
                picam2.configure(config)
                picam2.start()
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Biny failed', ex)).json
        finally:
            mutex.release()

@before(PreProcessRequest(maxdev))
class camerastate:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Returns one of the following status information:
            # 0 CameraIdle At idle state, available to start exposure
            # 1 CameraWaiting Exposure started but waiting (for shutter, trigger, filter wheel, etc.)
            # 2 CameraExposing Exposure currently in progress
            # 3 CameraReading CCD array is being read out (digitized)
            # 4 CameraDownload Downloading data to PC
            # 5 CameraError Camera error condition serious enough to prevent further operations (connection fail, etc.).
            # ----------------------
            resp.text = PropertyResponse(state.value, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Camerastate failed', ex)).json

@before(PreProcessRequest(maxdev))
class cameraxsize:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        # FIXME hard coded for HQ camera for now
        resp.text = PropertyResponse(SIZE_X, req).json

@before(PreProcessRequest(maxdev))
class cameraysize:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        # FIXME hard coded for HQ camera for now
        resp.text = PropertyResponse(SIZE_Y, req).json

@before(PreProcessRequest(maxdev))
class canabortexposure:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(True, req).json

@before(PreProcessRequest(maxdev))
class canasymmetricbin:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(False, req).json

@before(PreProcessRequest(maxdev))
class canfastreadout:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(False, req).json


@before(PreProcessRequest(maxdev))
class cangetcoolerpower:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(False, req).json


@before(PreProcessRequest(maxdev))
class canpulseguide:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(False, req).json


@before(PreProcessRequest(maxdev))
class cansetccdtemperature:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(False, req).json

@before(PreProcessRequest(maxdev))
class canstopexposure:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(False, req).json

@before(PreProcessRequest(maxdev))
class ccdtemperature:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                        NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class cooleron:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                        NotImplementedException()).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class coolerpower:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                    NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class electronsperadu:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # FIXME hard coded to HQ camera
            val = 0.469
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Electronsperadu failed', ex)).json

@before(PreProcessRequest(maxdev))
class exposuremax:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # FIXME hard coded to HQ camera
            val = 600
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Exposuremax failed', ex)).json

@before(PreProcessRequest(maxdev))
class exposuremin:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # FIXME hard coded for HQ camera
            val = 0.00006
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Exposuremin failed', ex)).json

@before(PreProcessRequest(maxdev))
class exposureresolution:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(0.0, req).json


@before(PreProcessRequest(maxdev))
class fastreadout:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class fullwellcapacity:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # FIXME hard coded HQ camera
            val = 8180
            # ----------------------
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Fullwellcapacity failed', ex)).json

@before(PreProcessRequest(maxdev))
class gain:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        resp.text = PropertyResponse(gainvalue, req).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        global gainvalue
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        gainstr = get_request_field('Gain', req)      # Raises 400 bad request if missing
        try:
            g = int(gainstr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'Gain {gainstr} not a valid number.')).json
            return
        ### RANGE CHECK
        if g < 0 or g > 16:
                resp.text = MethodResponse(req,
                            InvalidValueException(f'Gain {gainstr} is out of bounds.')).json
                return
        try:
            ### DEVICE OPERATION(PARAM) ###
            gainvalue = g
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Gain failed', ex)).json

@before(PreProcessRequest(maxdev))
class gainmax:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # FIXME hard coded to HQ camera
            val = 16
            # ----------------------
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Gainmax failed', ex)).json

@before(PreProcessRequest(maxdev))
class gainmin:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return

        resp.text = PropertyResponse(0, req).json

@before(PreProcessRequest(maxdev))
class gains:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class hasshutter:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        resp.text = PropertyResponse(False, req).json


@before(PreProcessRequest(maxdev))
class heatsinktemperature:
    # FIXME I think we can get this from image metadata. However, we're not retrieving metadata at the moment
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class imagearray:

    def on_get(self, req: Request, resp: Response, devnum: int):
        global imageReady
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        
        if not imageReady:
            resp.text = PropertyResponse(None, req,
                            InvalidOperationException()).json
            return
        
        try:
            try:
                mutex.acquire()
                array = picam2.wait(job).view(np.uint16) * (2 ** (16 - 12))
                imageReady = False # We've grabbed the image now
            finally:
                mutex.release()

            # Resize array to correct frame size according to max resolution and subframe settings
            array = array[start_y:start_y + num_y, start_x:start_x + num_x]
            array = np.transpose(array)

            accept = req.headers.get("ACCEPT")
            if accept is not None and 'XXimagebytes' in accept:
                # ImageBytes

                # Create response
                logger.debug("Creating ImageArrayResponse")
                pr = ImageArrayResponse(array, req)
                resp.data = pr.binary
                resp.content_type = 'application/imagebytes'
                logger.debug("Created ImageArrayResponse")

            else:
                # JSON - warning, this is speed optimized but it still much slower than imagebytes!

                # Convert array to a list of tuples, where each tuple is a column
                array = list(map(tuple, array.astype(int).tolist()))

                # Create response
                logger.debug("Creating ImageArrayResponse")
                pr = ImageArrayResponse(array, req)
                resp.text = pr.json 
                resp.content_type = 'application/json'
                logger.debug("Created ImageArrayJsonResponse")
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Imagearray failed', ex)).json

@before(PreProcessRequest(maxdev))
class imagearrayvariant(imagearray):
    def on_get(self, req: Request, resp: Response, devnum: int):
        super().on_get(req, resp, devnum)

def oncapturefinished(Job):
    global imageReady
    global state
    state = CameraState.IDLE
    imageReady = True
    logger.debug("oncapturefinished")

@before(PreProcessRequest(maxdev))
class imageready:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return

        resp.text = PropertyResponse(imageReady, req).json


@before(PreProcessRequest(maxdev))
class ispulseguiding:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class lastexposureduration:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class lastexposurestarttime:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class maxadu:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return

         # FIXME no idea but I think this is right, although for a 12bit sensor this would probably be 4095
        resp.text = PropertyResponse(65535, req).json

@before(PreProcessRequest(maxdev))
class maxbinx:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # FIXME hard coded to HQ camera
            val = 2
            # ----------------------
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Maxbinx failed', ex)).json

@before(PreProcessRequest(maxdev))
class maxbiny(maxbinx):

    def on_get(self, req: Request, resp: Response, devnum: int):
         super().on_get(req, resp, devnum)


@before(PreProcessRequest(maxdev))
class numx:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return

        resp.text = PropertyResponse(num_x, req).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        global num_x
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        numxstr = get_request_field('NumX', req)      # Raises 400 bad request if missing
        try:
            nnum_x = int(numxstr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'NumX {numxstr} not a valid number.')).json
            return
        ### RANGE CHECK AS NEEDED ###       # Raise Alpaca InvalidValueException with details!
        if nnum_x < 0 or nnum_x > SIZE_X: # FIXME do we need to take binning into account?
            resp.text = MethodResponse(req,
                            InvalidValueException(f'NumX {numxstr} is out of bounds.')).json
            return
        try:
            ### DEVICE OPERATION(PARAM) ###
            num_x = nnum_x
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Numx failed', ex)).json

@before(PreProcessRequest(maxdev))
class numy:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        resp.text = PropertyResponse(num_y, req).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        global num_y
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        numystr = get_request_field('NumY', req)      # Raises 400 bad request if missing
        try:
            nnum_y = int(numystr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'NumY {numystr} not a valid number.')).json
            return
        ### RANGE CHECK AS NEEDED ###       # Raise Alpaca InvalidValueException with details!
        if nnum_y < 0 or nnum_y > SIZE_Y: # FIXME do we need to take binning into account?
            resp.text = MethodResponse(req,
                            InvalidValueException(f'NumY {numystr} is out of bounds.')).json
            return
        try:
            ### DEVICE OPERATION(PARAM) ###
            num_y = nnum_y
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Numy failed', ex)).json

@before(PreProcessRequest(maxdev))
class offset:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class offsetmax:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class offsetmin:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class offsets:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class percentcompleted:

    def on_get(self, req: Request, resp: Response, devnum: int):
        # FIXME perhaps we can calculate this from exposure start time?
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class pixelsizex:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # FIXME hard coded HQ camera
            val = 1.55
            # ----------------------
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Pixelsizex failed', ex)).json

@before(PreProcessRequest(maxdev))
class pixelsizey(pixelsizex):

    def on_get(self, req: Request, resp: Response, devnum: int):
        super().on_get(req, resp, devnum)

@before(PreProcessRequest(maxdev))
class readoutmode:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        resp.text = PropertyResponse(0, req).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        readoutmodestr = get_request_field('ReadoutMode', req)      # Raises 400 bad request if missing
        try:
            readoutmode = int(readoutmodestr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'ReadoutMode {readoutmodestr} not a valid number.')).json
            return
        ### RANGE CHECK FIXME
        try:
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Readoutmode failed', ex)).json

@before(PreProcessRequest(maxdev))
class readoutmodes:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return

        resp.text = PropertyResponse(["default"], req).json

@before(PreProcessRequest(maxdev))
class sensorname:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # FIXME hard coded HQ camera
            val = "IMX477"
            # ----------------------
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Camera.Sensorname failed', ex)).json

@before(PreProcessRequest(maxdev))
class sensortype:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return

        resp.text = PropertyResponse(2, req).json

@before(PreProcessRequest(maxdev))
class setccdtemperature:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class startx:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        resp.text = PropertyResponse(start_x, req).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        global start_x
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        startxstr = get_request_field('StartX', req)      # Raises 400 bad request if missing
        try:
            nstart_x = int(startxstr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'StartX {startxstr} not a valid number.')).json
            return
        ### RANGE CHECK AS NEEDED ###       # Raise Alpaca InvalidValueException with details!
        if nstart_x < 0 or nstart_x > SIZE_X:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'StartX {startxstr} is out of bounds.')).json
            return
        try:
            ### DEVICE OPERATION(PARAM) ###
            start_x = nstart_x
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Startx failed', ex)).json

@before(PreProcessRequest(maxdev))
class starty:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return

        resp.text = PropertyResponse(start_y, req).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        global start_y
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        startystr = get_request_field('StartY', req)      # Raises 400 bad request if missing
        try:
            nstart_y = int(startystr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'StartY {startystr} not a valid number.')).json
            return
        ### RANGE CHECK AS NEEDED ###       # Raise Alpaca InvalidValueException with details!
        if nstart_y < 0 or nstart_y > SIZE_Y:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'StartY {startystr} is out of bounds.')).json
            return
        try:
            ### DEVICE OPERATION(PARAM) ###
            start_y = nstart_y
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Starty failed', ex)).json

@before(PreProcessRequest(maxdev))
class subexposureduration:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json    

    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class abortexposure:

    def on_put(self, req: Request, resp: Response, devnum: int):
        global state
        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:    
            if state == CameraState.EXPOSING:
                picam2.stop_()
                state = CameraState.IDLE
                picam2.start()
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Abortexposure failed', ex)).json

@before(PreProcessRequest(maxdev))
class pulseguide:

    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class startexposure:

    def on_put(self, req: Request, resp: Response, devnum: int):

        global state
        global job
        global imageReady

        if not picam2.started:
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        durationstr = get_request_field('Duration', req) 
        try:
            duration = float(durationstr)
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'Duration {durationstr} not a valid number.')).json
            return
        
        ### RANGE CHECK AS NEEDED ###
        if duration < 0 or duration > 127:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'Duration {durationstr} is out of bounds')).json
            return

        try:
            ### DEVICE OPERATION(PARAM) ###
            mutex.acquire()
            logger.debug("Exposure duration is %f, gain is %d", duration, gainvalue)

            with picam2.controls as controls:
                controls.ExposureTime = int(duration * 1e6)
                controls.AeEnable = False
                controls.NoiseReductionMode = libcamera.controls.draft.NoiseReductionModeEnum.Off
                controls.AwbEnable = False
                controls.AnalogueGain = gainvalue
                #controls.ColourGains = (2.0, 2.0)

            job = picam2.capture_array("raw", signal_function=oncapturefinished)
            state = CameraState.EXPOSING
            # -----------------------------
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Camera.Startexposure failed', ex)).json
        finally:
            mutex.release()

@before(PreProcessRequest(maxdev))
class stopexposure:

    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(None, req,
                NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class connected:

    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(picam2.started, req).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        conn_str = get_request_field('Connected', req)
        conn = to_bool(conn_str)              # Raises 400 Bad Request if str to bool fails

        # start/stop
        if (conn):
            try:
                # ----------------------
                mutex.acquire()
                if not picam2.started:
                    # FIXME hard coded HQ cam
                    config = picam2.create_still_configuration( {"size": (640, 480)}, queue=False, buffer_count=2,  raw={'format': 'SRGGB12','size': (int(SIZE_X / binning), int(SIZE_Y / binning))})
                    picam2.configure(config)
                    picam2.start()
                # ----------------------
                resp.text = MethodResponse(req).json
            except Exception as ex:
                resp.text = MethodResponse(req,
                                DriverException(0x500, f'{self.__class__.__name__} failed', ex)).json
            finally:
                mutex.release()
        else:  
            try:
                # ----------------------
                mutex.acquire()
                if picam2.started:
                    picam2.stop()
                # ----------------------
                resp.text = MethodResponse(req).json
            except Exception as ex:
                resp.text = MethodResponse(req,
                                DriverException(0x500, f'{self.__class__.__name__} failed', ex)).json
            finally:
                mutex.release()
